<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2주차ㅣ| 복습발표</title>
  <link rel="stylesheet" href="../assets/css/reset.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css"/>
  <link rel="stylesheet" href="../assets/css/common.css">
  <link rel="stylesheet" href="../assets/css/page.css">
  <script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>
  <script src="../assets/js/page.js"></script>
</head>
<body>
  <div id="root">
    <header>
      <h1><a href="../index.html">프로그래머스 복습발표</a></h1>
    </header>
    <div class="container container-1 branch">
      <div class="inner">
        <h2>브랜치</h2>
        <article class="part1">
          <div class="title">깃 플로우</div>
          <div class="content notion-1">
            <pre class ="info">브랜치를 생성하는 이유는 메인 프로젝트를 보호하기 위함 입니다.
깃을 사용하지 않고 사이트를 제작을 할때도 마찬가지인데 서비스중인 사이트를 직접적으로 고치는건 큰 위험이 따른다.
빠르게 수정할 수 있는 거라면 그나마 괜찮지만 수정할 양이 너무 많고 바뀌는게 보이면 클라이언트가 사이트를 이용하다가 놀라기 때문이다.
이런 이유로 우리는 브랜치를 전략을 이용하여 브랜치를 사용합니다.
브랜치 전략은 크게 두가지로 나뉘는데 바로 fast forword와 3-way이다.</pre>
            <ul class="col col-2">
              <li>
                <h3>fast forword</h3>
                <p>메인 프로젝트를 직접적으로 수정하지 않고 빠르게 수정할 수 있는 전략으로 대부분 충돌없으며 이름 그대로 빠른수정이 장점이다.</p>
                <p><img src="../assets/img/fast forword.gif" alt="fast forword 전략"></p>
              </li>
              <li>
                <h3>3-way</h3>
                <p>가장 많이 사용되는 전략으로 3-way 전략의 첫 병합은 fast forword 방식으로 병합이 되지만 이후 병합하는 과정에서 다른 위치를 수정을 하게되면 비교 과정을 거친 뒤에 메인 프로젝트에 병합이 진행되지만 같은 페이지의 같은 위치를 수정한 기록이 있으면 충돌이 발생한다. </p>
                <p><img src="../assets/img/3-way.gif" alt="3-way"></p>
              </li>
            </ul>
          </div>
          <div class="content notion-2">
            <pre class="info">저장소의 데이터를 가져오는 방식은 총 두가지가 있다. 바로 pull과 fetch이다. 둘중 아무거나 사용해도 되나? 하면 병합을 언제 하냐에 따라 저장을 하면 된다.
pull은 자동으로 깃허브의 커밋들을 내려받아서 병합을 한다.
하지만 fetch의 경우에는 임시브랜치에 내려 받은 뒤 merge를 통해 수동으로 병합을 진행해야한다.</pre>
          </div>
          <div class="content notion-3">
            <pre class="info">브랜치 생성은 아주 간단한데 <code>git branch 브랜치명</code> 이 명령어를 실행하면 바로 생성이 가능하다.
            </pre>
            <h3>사용 시 주의 할 점</h3>
            <pre>깃허브에 올라간 프로젝트와 로컬에 저장된 프로젝트가 다르다면 브랜치 생성을 할때 코드가 달라지기 때문이다. 그렇다면 이 방법은 아예 안쓰나? 하면 아니다 사용한다. 대신에 git fetch 혹은 git pull을 통해 깃허브와 로컬 프로젝트를 동일하게 만든 다음에 사용하는것이 좋다.</pre>
            </pre>
          </div>
          <div class="content notion-4">
            <pre class="info">"깃허브"에서 브랜치를 생성을 하고 vscode에서 <code>git checkout -t 저장소브랜치명</code>을 입력하면 따로 로컬에 브랜치 생성을 하지 않아도 저장소의 브랜치를 그대로 생생을 해준다. 브랜치명을 확인할 때는 <code>git branch -r</code>혹은 <code>git branch -a</code>을 이용해 저장소브랜치명을 확인 할 수 있다.
만약 분명 깃허브에서 브랜치를 생성했는데 로컬에서 확인이 불가능하다면 <code>git fetch -p</code>를 입력한 뒤에 위의 명령어를 다시 입력해 확인을 할 수 있다.</pre>
          </div>
          <div class="content notion-5">
            <pre class="info">브랜치를 생성한 뒤 병합을 하면 우리가 만날 수 있는 문제가 바로 충돌입니다.
새로 브랜치를 만들어 push를 하면 깃허브에 pull request가 뜨는데요 깃허브에서 자동으로 분석을 진행하는데 문제가 없는 경우에는 바로 병합이 가능하고 동일한 페이지 동일한 위치에 수정을 했을 경우 충돌이 발생합니다.
충돌이 발생할 경우 resolve confilicts를 통해서 필요한 데이터만 남기고 필요없는 데이터는 지운 뒤에 다시 제출 하면 깃허브가 이상이 없는지 확인 한 뒤 문제가 없을 경우 병합을 진행 할 수 있습니다.
            </pre>
            <p class="col"><img src="../assets/img/pull request.png" alt="PR"></p>
          </div>
          <button type="button" class="btn-one" onclick="onButtonOne('week2','part1')">1</button>
          <button type="button" class="btn-two" onclick="onButtonTwo('week2','part1')">2</button>
          <button type="button" class="btn-third" onclick="onButtonThird('week2','part1')">3</button>
          <button type="button" class="btn-4th" onclick="onButton4th('week2','part1')">4</button>
          <button type="button" class="btn-5th" onclick="onButton5th('week2','part1')">5</button>
        </article>
      </div>
    </div>
    <div class="container container-2 frontend">
      <div class="inner">
        <h2>프론트엔드 HTML, CSS, javascript</h2>
        <article class="part2">
          <div class="title">HTML과 CSS와 javascript</div>
          <div class="content notion-1">
            <pre class="info">사이트를 구성하는 기본적인 요소는 바로 HTML, CSS, javascript이다. 그렇다면 이 언어들이 무엇인지 알아보자</pre>
            <ul class="col col-3">
              <li>
                <h3>HTML</h3>
                <pre>HTML은 웹페이지를 연결하는 기능을 가진 텍스트이자 웹페이지를 구성하는 태그들로 이루어진 언어이며 HTML만 존재한다면 디자인 요소는 하나도 존재 하지 않는다.</pre>
              </li>
              <li>
                <h3>CSS</h3>
                <pre>CSS는 디자인이 없는 HTML을 꾸미기 위한 언어로 클라이언트가 이용하는데 불편함이 없게 UX/UI를 신경써서 작업을 해야한다. </pre>
              </li>
              <li>
                <h3>javascript</h3>
                <pre>javascript는 꼭두각시 인형에 실을 달아 움직일수 있게 만들듯이 HTML과 CSS로 만든 페이지를 javascript로 살아 숨쉬는 듯한 페이지로 만드는 동적 기능들을 제어할 수 있는 언어이다.</pre>
              </li>
            </ul>
          </div>
          <div class="content notion-2">
            <pre>
              <xmp>
                <!DOCTYPE html>
                <html lang="ko">
                  <head>
                    <meta charset="utf-8">
                    <title>문서 제목</title>
                  </head>
                  <body>
                    웹페이지구성
                  </body>
                </html>
              </xmp>
            </pre>
          </div>
          <div class="content notion-3">
            <pre class="info">head는 웹사이트의 정보를 저장하는 곳인데 기본적으로 작성하면 좋은 메타태그를 설명해보려한다.</pre>
            <table>
              <tr>
                <th>속성</th>
                <th>설명</th>
              </tr>
              <tr>
                <td>charset</td>
                <td>문서의 인코딩 방식을 정하는 속성</td>
              </tr>
              <tr>
                <td>viewport</td>
                <td>여러장치에서 웹사이트가 어떻게 보였으면 좋을지 정하는 속성</td>
              </tr>
              <tr>
                <td>content</td>
                <td>meta태그의 속성들의 내용을 넣을 때 사용되는 속성</td>
              </tr>
              <tr>
                <td>title/keywords/description</td>
                <td>사이트의 타이틀, 키워드, 설명을 설정하는 속성으로 content 속성을 이용해 내용들을 입력하면 SEO 최적화에 사용된다</td>
              </tr>
            </table>
          </div>
          <div class="content notion-4">
            <img src="../assets/img/css-struct.png" alt="css 구조">
            <pre>
다양한 선택자 종류가 있습니다.
기본적으로 태그, 아이디명, 클래스명을 이용을 하며

관계를 이용해서 작성하는 선택자도 있다.
p span : p태그 안에 존재하는 "모든" span태그
p > span : p태그 바로 "하위"에 존재하는 span태그
p ~ p :p태그의 형제 요소에 있는 모든 p태그
p + h3 : p태그의 형제 요소중에 p 아래에 존재하는 h3태그
p:nth-child(n) : n번째에 존재하는 p태그

상태를 가지고 작성하는 선택자도 있다.
p:hover : p태그에 마우스를 올렸을 때
input:focus : input 태그에 포커스가 갔을 때
등등 다양한 선택자가 존재한다.
            </pre>
          </div>
          <div class="content notion-5">
            <pre class="info">동적 기능을 사용하려면 css에서 선택자를 선택한것처럼 javascript도 마찬가지로 해당태그를 선택을 해야한다.
그렇다면 태그를 선택을 어떻게 해야하는가? 바로 getElement와 querySelector를 이용을 할 수 있다.
documnet.getElementByID('선택자') 매번이렇게 작성을 하는 번거로움을 없애기 위해 우리는 변수라는 기능을 사용할것이다.</pre>
            <h3>변수는 무엇인가?</h3>
            <pre>변수는 쉽게 생각해서 이름이다. 똑같이 생긴 네모 박스를 우리가 상자라고 부르는것처럼 데이터들을 특정이름으로 지정을해서 이름을 부르면 해당 데이터가 나오는 원리이다.</pre>
            <h3>함수는 무엇인가?</h3>
            <p>
                함수는 특정 기능을 수행하는 코드
                <img src="../assets/img/function-struct.png" alt="함수구조">
            </p>
          </div>
          <div class="content notion-6">
            <h3>변수는 어디에 있어야하는가?</h3>
            <p>변수의 위치에 따라 접근할 수 있는 범위가 다르다. 우리는 그걸 스코프라고 정의했다.</p>
            <p>스코프는 전역변수와 지역변수가 존재한다. </p>
            <ul class="col col-2">
              <li>
                <h3>전역변수</h3>
                <p>전역변수는 javscript의 제일 바깥에 존재하며 변수를 전역에서 사용이 가능하다.</p>
                <pre>
let a = 111
function func(){
  console.log(a)
}
func() // '111'
console.log(a) // '111'
                </pre>
              </li>
              <li>
                <h3>지역변수</h3>
                <p>지역변수는 말그대로 지역에서만 사용한 변수를 뜻하며 여기서 지역이란 함수안에서 생성한 변수이다. 함수안에서 생성했다해서 함수 스코프라고도 한다. 아래 코드를 보면 함수안에서 변수 값을 수정을 했지만 바깥에있는 console에는 영향을 주지 못한 것을 볼수 있는데 이게 지역변수의 가장 큰 특징이다.</p>
                <pre>
let a = 111
function func(){
  a = 11
  console.log(a)
}
func(); // '11'
console.log(a) // '111'
                </pre>
              </li>
            </ul>
          </div>
          <button type="button" class="btn-one" onclick="onButtonOne('week2','part2')">1</button>
          <button type="button" class="btn-two" onclick="onButtonTwo('week2','part2')">2</button>
          <button type="button" class="btn-third" onclick="onButtonThird('week2','part2')">3</button>
          <button type="button" class="btn-4th" onclick="onButton4th('week2','part2')">4</button>
          <button type="button" class="btn-5th" onclick="onButton5th('week2','part2')">5</button>
          <button type="button" class="btn-6th" onclick="onButton6th('week2','part2')">6</button>
        </article>
      </div>
    </div>
    <div class="container container-3 backend">
      <div class="inner">
        <h2>백엔드 node, DB, SQL</h2>
        <article class="part3">
          <div class="title">모듈이란?</div>
          <div class="content notion-1">
            <pre class="info">지난주 복습 발표때 javascript의 환경이 바뀌면서 스크립트언어 뿐만 아니라 프로그래밍 언어 역할을 수 있게 됐다고 말했는데 이때 javascript 중 node라는 javascript를 이용하려한다.</pre>
            <p>node를 설치를 하면 node에서 기본적으로 제공하는 모듈을 사용할 수 있게된다. 추가적으로 필요한 경우에는 설치를 통해 다양한 모듈들을 사용할수 있다. </p>
            <h3>모듈이란 무엇일까?</h3>
            <pre>모듈은 쉽게 말해 함수이다. 우리가 필요한 기능들을 만들고 기능이 필요한 위치에 호출을 해서 사용할 수 있게 한다.

그렇다면 모듈은 어떻게 만드는가?
모듈은 exports를 통해 함수를 내보내 다른곳에서 사용할 수 있게 하는것이다. 그렇다면 exports는 어떻게 하는가? 아주 간단하다. <code>module.exports = 내보낼 기능</code>을 해당 js 파일에 작성해주면 모듈이 완성된다.
            </pre>
            <h3>모듈은 어떻게 사용하는가?</h3>
            <pre>모듈을 사용하는 방법도 엄청 간단하다 바로 사용할 파일에서 require을 이용해 모듈을 가져오는것이다. <code>require('만든 모듈 : 경로/ 설치한 모듈 : 모듈이름')</code> 변수로 모듈을 정의하면 모듈을 사용할 준비가 끝이난다.</pre>
          </div>
          <div class="content notion-2">
            <p>node로 서버를 구축하는 방법은 http와 express가 있는데 우리는 http를 통해 서버를 구축을 할 것이다.</p>
            <p>node에서 제공하는 모듈인 http를 가져온 뒤에 <code>http.createServer(생성할 서버).listen(포트)</code>를 입력해주면 서버 생성은 끝이난다.</p>
            <h3>request(요청)와/과 response(응답)</h3>
            <p>서버를 구축하면 가장많이 접하는게 바로 request(요청)와(과) response(응답)이다.</p>
            <p>요청은 클라이언트가 필요한 자료를 달라고 할때 전송받는 데이터, 응답은 찾은 자료를 클라이언트한테 정보를 넘길때 사용한다.</p>
            <h3>응답은 어떻게 하나?</h3>
            <p>응답은 기본적으로 정보를 제공을 하는 것이다. writeHead를 통해 어떤 타입인지, 통신상태는 어떤지를 전달하고, write에서는 보여주고싶은 화면을 전달한다. 이렇게 writeHead와 write를 작성하면 무조건 전송이 끝났다는 end를 보내줘야 한다.</p>
            <pre>
응답.writeHead(200, {'Content-Type':'text/html'})
응답.write('화면 코드')
응답.end()
            </pre>
          </div>
          <div class="content notion-3">
            <pre class="info">사이트의 크기가 커지면 커질수록 관리해야하는 주소들이 많아지면서 각각의 주소에 필요한 정보들을 제공을 해줘야하는데 그 경로들을 server에서 진행을 하게 되면 코드가 복잡해 지기 때문에 모듈을 이용해 각 기능에 맞게 분리를 하게 된다.</pre>
            <ul class="col col-2">
              <li>
                <h3>라우터</h3>
                <p>라우터는 서버와 핸들러 사이에 존재하고 서버와 핸들러를 연결해 주는데 <span class="c-red fwb">주소에 맞는 핸들러를 연결</span>해 주는 길잡이 역할이다.</p>
              </li>
              <li>
                <h3>핸들러</h3>
                <p>핸들러는 특정 경로에 진입을 했을 때 작동했으면 하는 <span class="c-red fwb">동작 기능</span>들을 작성한 파일이다.</p>
              </li>
            </ul>
          </div>
          <div class="content notion-4">
            <pre class="info">스키마는 메타데이터의 집합으로 목적을 가지고 만들어진 데이터이며 우리가 흔히 데이터베이스 라고도 부른다.
스키마에는 메타데이터의 집합으로 구성 되어있다 했는데 그 구성들을 테이블이라한다.</pre>
<img src="../assets/img/db-struct.png" alt="db구조">
          </div>
          <div class="content notion-5">
            <pre class="info">sql은 데이터베이스를 조작하는 언어이다.</pre>
            <h3>생성 CREATE</h3>
            <pre>데이터베이스 스키마를 생성하고 데이터테이블을 생성하는데 사용되는 명령어로
  스키마 생성 : <code>create database 스키마명</code>
  테이블 생성 : <code>create table 테이블명 {컬럼A 타입, 컬럼B 타입, ...}</code>
이렇게 명령을 실행할 수 있는데 테이블 생성의 경우에는 스키마 안에서 명령어를 작성을 해야한다.
            </pre>
            <h3>데이터 조회 SELECT</h3>
            <pre>테이블에 들어가있는 데이터들을 조회할 때 사용하며
<code>select 컬럼명 from 테이블명</code>을 기본구조로 되어있고
컬럼명 위치에 모든 컬럼을 불러오려면 *을 사용하고
특정 행(row)만 가져오려면 select 컬럼명 from 테이블명 where 조건컬럼 = 조건값으로 조회가 가능하다.
            </pre>
            <h3>데이터 넣기 INSERT</h3>
            <pre>테이블을 만들었으면 데이터를 넣어야하는데 그때 사용되는 명령어이다.
모든 데이터를 넣을 때 : <code>insert into 테이블명 values ('컬럼값A', 'B', 'C')</code>
일부 데이터를 넣을 때 : <code>insert 컬럼 A, B, C into 테이블명 values ('컬럼값A','B','C')</code>
데이터를 넣을때는 모든 데이터를 넣을것이냐 일부만 넣을것이냐에 따라 입력할수 있는 명령어가 조금 차이가 있다.
            </pre>
            <h3>데이터 수정 UPDATE</h3>
            <pre>우리가 가장 많이 보는 예시를 들자면 비밀번호 변경이 있다. 우리가 많은 데이터 수정을 요청 하는데 그때 사용하는 명령어는
모든 데이터를 수정할 때 : <code>update 테이블 set 바꿀컬럼 = '바꿀값'</code>
일부 데이터만 수정할 때 : <code>update 테이블 set 바꿀컬럼 = '바꿀값' where 조건컬럼 = 조건값</code>
이다. where절의 유무는 일부 데이터만 바꿀것인가, 혹은 전체 데이터를 바꿀것인가의 차이가 있다.
            </pre>
            <h3>데이터 삭제  DELETE</h3>
            <pre>데이터 삭제는 컬럼값만 삭제하는게 아니라 한개의 행(row)을/를 삭제한다. 명령어는 select와 유사한데
모든 데이터(행) 삭제할 때 : <code>delete from 테이블명</code>
특정 데이터(행) 삭제할 떄 : <code>delete from 테이블명 where 조건컬럼 = 조건값</code>
update와 마찬가지로 where을 적으면 조건에 맞는 행만 삭제를 하고 where 적지 않으면 모든 행을 삭제하게 된다.
            </pre>
          </div>
          <button type="button" class="btn-one" onclick="onButtonOne('week2','part3')">1</button>
          <button type="button" class="btn-two" onclick="onButtonTwo('week2','part3')">2</button>
          <button type="button" class="btn-third" onclick="onButtonThird('week2','part3')">3</button>
          <button type="button" class="btn-4th" onclick="onButton4th('week2','part3')">4</button>
          <button type="button" class="btn-5th" onclick="onButton5th('week2','part3')">5</button>
        </article>
      </div>
    </div>
  </div>
</body>
</html>
