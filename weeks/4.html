<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4주차ㅣ| 복습발표</title>
    <link rel="stylesheet" href="../assets/css/reset.css" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css"
    />
    <link rel="stylesheet" href="../assets/css/common.css" />
    <link rel="stylesheet" href="../assets/css/page.css" />
    <script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>
    <script src="../assets/js/page.js"></script>
  </head>
  <body>
    <div id="root">
      <header>
        <h1><a href="../index.html">프로그래머스 복습발표</a></h1>
      </header>
      <div class="container container-1 frame-library">
        <div class="inner">
          <h2>프레임워크와 라이브러리</h2>
          <article class="part1">
            <div class="title">라이브러리란?</div>
            <div class="content notion-1">
              <pre class="info">
라이브러리는 쉽게 말해서 책들의 집합이라고 볼 수 있습니다. 프로그래밍에서 말하는 라이브러리는 특정한 주제에 대해서 그 주제를 조금 더 구체적으로 다루는 책들이 되는것입니다.</pre
              >
              <br />
              <h3>왜 라이브러리를 사용할까?</h3>
              <p>
                라이브러리를 사용하는 이유로는 모든기능을 직접적으로 코딩을 할
                수 없고, 시간을 절약할수 있기 때문에 라이브러리를 사용합니다.
              </p>
              <p>
                라이브러리는 대부분 class형이나 function(함수)로 정의를 하며
                필요할때 호출하여 사용이 가능한데요 이때 코드의 전체적인 흐름에
                영향을 주는게 아니기 때문에 주도권은 라이브러리가 아닌
                사용자에게 있습니다.
              </p>
            </div>
            <div class="content notion-2">
              <pre class="info">
보통 어플리케이션을 빠르고 효율적으로 개발 할수 있도록 지원합니다. 그래서 프레임워크는 프로그래밍 언어가아니라 프로그램 구축을 위한 구조로 사전 구축된 도구, 라이브러리의 집합이라고 볼 수 있습니다.</pre
              >
              <br />
              <h3>왜 프레임워크를 사용할까요?</h3>
              <p>
                프레임워크를 사용하는 이유 중 하나는 효율적이기 때문입니다.
                예시를 들어볼까요? 우리가 배우는 express도 프레임워크입니다.
                이때 express-generator를 이용하여 웹서버 구축에 필요한 기본적인
                틀을 한번에 설치하여 시간을 단축시간다는 점에 있습니다.
              </p>
              <p>
                또한 유지보수 측면에서도 나쁘지 않은데요 개인이 하나부터 열까지
                짜는 코드는 아무래도 다른사람이 봤을때 바로 작업하기 어렵습니다.
                하지만 이렇게 프레임워크에서 제공하는 틀을 이용하면 작업자가
                바뀌더라도 틀대로 작업을 하다보니 유지보수에 있어서 안정적이다
                라고 말할 수있습니다.
              </p>
            </div>
            <div class="content notion-3">
              <pre class="info">
라이브러리와 프레임워크의 종류에 대해서 알아봅시다.</pre
              >
              <ul class="col col-2">
                <li>
                  <h3>라이브러리</h3>
                  <p>React</p>
                  <p>jQuery</p>
                  <p>npm 모듈</p>
                </li>
                <li>
                  <h3>프레임워크</h3>
                  <p>Vue.js</p>
                  <p>Agular.js</p>
                  <p>Express.js</p>
                </li>
              </ul>
              <p>
                놀랍게도 React는 프레임워크가 아닌 라이브러리인데요. React는
                우리가 흔히 MVC패턴이라고 불리는 것중에 오로지 V(view)만을
                신경쓰는 라이브러리이니 헷갈리지 말도록 합시다.
              </p>
            </div>
            <div class="content notion-4">
              <pre class="info">
제어의 역전이란? 객체나 메서드의 제어를 개발자가 아닌 외부에 위임을 하는 설계 원칙을 말합니다. 너무 어렵죠? 쉽게 말하자면 방을 청소하기 위해 청소기를 구매를 해서 내가 청소를 하면 제어하는 건 사람, 즉 내가 되지만, 청소기를 구매했는데 로봇청소기를 구매를 해서 로봇청소기 자체가 청소를 하면 제어를 하는건 바로 로봇청소기가 됩니다. 이때 나(개발자) 대신 제어를 해주는 현상을 제어의 역전이라고 할 수 있습니다.

제어의 역전은 프레임워크에서 일어난다 라고 할 수 있습니다. 왜냐하면 나(개발자) 대신 라이브러리나 다른 것을 프레임워크가 제어해 주기 때문입니다.</pre
              >
            </div>
            <button
              type="button"
              class="btn-one"
              onclick="onButtonOne('week4','part1')"
            >
              1
            </button>
            <button
              type="button"
              class="btn-two"
              onclick="onButtonTwo('week4','part1')"
            >
              2
            </button>
            <button
              type="button"
              class="btn-third"
              onclick="onButtonThird('week4','part1')"
            >
              3
            </button>
            <button
              type="button"
              class="btn-4th"
              onclick="onButton4th('week4','part1')"
            >
              4
            </button>
          </article>
        </div>
      </div>
      <div class="container container-2 destructure-assign">
        <div class="inner">
          <h2>구조분해할당과 전개(spread) 연산</h2>
          <article class="part2">
            <div class="title">배열의 구조 분해 할당</div>
            <div class="content notion-1">
              <pre class="info">
구조 분해 할당이란? 비구조화 할당이라고도 하며 객체나 배열에 저장된 데이터 전체보다 일부만 필요한 상황이 생기는데 이때 객체나 배열을 변수로 분해하여 사용할 수 있게 해주는 문법입니다.</pre
              >
              <br />
              <h3>배열을 구조분해 해보자</h3>
              <p>
                방법은 간단한데요 배열([])안에 우리가 원하는 변수값을 넣고 그
                값을 배열로 대입하는 방식입니다.
              </p>
              <p>예시 → const [num1, num5] = [1,2,3,4,5]</p>
              <p>
                변수 num1과 num5를 구조분해할당을 한것인데요. 이때 num1과 num5가
                받아오는 값은 각각 1과 2입니다. 만약에 1과 5를 담고 싶은
                경우에는
              </p>
              <p>예시 → const [num1, , , , num5] = [1,2,3,4,5]</p>
              <p>
                이와같이 배열에 공간을 집어넣어서 필요한 값에 매칭이 되게 해주면
                되는데요. 이를 통해 알 수 있는건 바로 배열의 구조분해할당은 바로
                순차적으로 값을 넣는다 라는 것입니다.
              </p>
            </div>
            <div class="content notion-2">
              <pre class="info">
                구조 분해 할당이란? 비구조화 할당이라고도 하며 객체나 배열에 저장된 데이터 전체보다 일부만 필요한 상황이 생기는데 이때 객체나 배열을 변수로 분해하여 사용할 수 있게 해주는 문법입니다.</pre
              >
              <br />
              <h3>객체를 구조분해 해보자</h3>
              <p>
                객체의 구조분해도 아주 간단합니다. 배열에서 구조분해할때 []를
                사용한것처럼 객체에서도 마찬가지로 객체 형태인 {}를 사용하면
                됩니다.
              </p>
              <p>
                예시 → const {a,d} = {'a' : 10, 'b': 20, 'c':30, 'd':40, 'e':
                50}
              </p>
              <p>
                배열 구조분해할당에서는 인자의 순서대로 값을 할당했는데요 객체
                구조분해시에 a와 d를 가져오면 어떤 값을 가져오게 될까요?
                배열처럼 10과 20을 가져올까요? 정답은 아닙니다. 객체의
                구조분해할당에서는 key값과 변수명이 일치를 해야 값을 가져오는데
                이때 가져오는 값은 key의 value 값이 됩니다. 즉 가져오는 값은
                10과 40이 됩니다.
              </p>
              <p>
                만약에 key값으로 변수명을 받고 싶지 않다면 아래와 같이 설정이
                가능합니다.
              </p>
              <p>
                예시 → const {a : 'ten',d : 'forty'} = {'a' : 10, 'b': 20,
                'c':30, 'd':40, 'e': 50}
              </p>
            </div>
            <div class="content notion-3">
              <pre class="info">
spread 연산자는 언제 사용하나요? 스프레드 연산자라 불리는 전개 연산자는 객체나 배열을 나열해 주는것을 말합니다. 구조분해할당에서 사용하는 경우에는 나머지 값들을 모아주는데 사용되기도 합니다.

이때 배열에서의 나머지는 전개구문이 시작되는 인자부터 마지막까지를 담고, 객체에서의 나머지는 할당되지 않은 것들을 모아줍니다.
              </pre>
              <br />
              <h3>배열에서의 전개연산자</h3>
              <p>const [num1, num2, ...rest] = [1,2,3,4,5]</p>
              <p>console.log(num1, num2, rest) // 1, 2, [3,4,5]</p>
              <h3>객체에서의 전개연산자</h3>
              <p>
                const {a, d, ...rest} = { a: 10, b: 20, c: 30, d: 40, e: 50 }
              </p>
              <p>console.log(a, d, rest) // 10, 40, { b: 20, c: 30, e: 50 }</p>
            </div>
            <div class="content notion-4">
              <pre class="info">
수업중에 Map 객체에 데이터를 넣어보는 연습을 한적이 있는데 이걸 spread를 이용해서 사용하는 방법도 있다는걸 알려드리고 싶어서 작성했습니다.</pre
              >
              <pre>
const db = new Map();

db.set(1, { title: "news", company: "쇼엠" })
  .set(2, "blog")
  .set("name", "dung")
  .set(3, "bag");

app.get("/:id", (요청, 응답) => {
  let { id } = 요청.params;
  id = parseInt(id);

  const newDb = { id: id, ...db.get(id) };
  응답.json({
    data: newDb
  });
});
              </pre>
            </div>
            <button
              type="button"
              class="btn-one"
              onclick="onButtonOne('week4','part2')"
            >
              1
            </button>
            <button
              type="button"
              class="btn-two"
              onclick="onButtonTwo('week4','part2')"
            >
              2
            </button>
            <button
              type="button"
              class="btn-third"
              onclick="onButtonThird('week4','part2')"
            >
              3
            </button>
            <button
              type="button"
              class="btn-4th"
              onclick="onButton4th('week4','part2')"
            >
              4
            </button>
          </article>
        </div>
      </div>
      <div class="container container-3 map-object">
        <div class="inner">
          <h2>Map 객체</h2>
          <article class="part3">
            <div class="title">Map 객체의 시작</div>
            <div class="content notion-1">
              <pre class="info">
Map객체는 ES6 문법으로 key-value를 한쌍으로 가지는 객체입니다. 이때 key의 값은 고유해야하며 값은 변경이 가능합니다. 또한 Map의 가장 큰 특징으로는 key값으로 다양한 데이터 타입을 사용할수 있다는 점에있습니다. 기존에 Object는 string과 symbol만 받아온다는 차이가 있습니다.</pre
              >
              <br />
              <h3>Map 사용하기</h3>
              <p>Map 사용은 아주 간단합니다.</p>
              <p>const 변수명 = new Map();</p>
              <p>
                이렇게 선언을 해주면 Map 사용 준비가 끝이 납니다. 그렇다면 Map은
                어떻게 사용하는걸까요? 다양한 속성과 메서드를 알아봅시다.
              </p>
            </div>
            <div class="content notion-2">
              <pre class="info">
const db = new Map();
db.set(1, 'news').set(2, 'blog').set('name', 'dung').set(3, 'bag')
위의 Map 객체를 이용하여 다양한 속성과 메서드를 알아봅시다.</pre
              >
              <table class="mt-10 child-pd-10">
                <tr class="bb1">
                  <th>속성과 메서드</th>
                  <th>설명</th>
                  <th>결과</th>
                </tr>
                <tr>
                  <td>db.size</td>
                  <td>객체의 key, value 한쌍의 숫자를 반환</td>
                  <td>4</td>
                </tr>
                <tr>
                  <td>db.set('age',20)</td>
                  <td>Map에 key와 value값을 순서대로 삽입</td>
                  <td>
                    Map(5) {1 => 'news', 2 => 'blog', 'name' => 'dung', 3 =>
                    'bag', 'age' => 20 }
                  </td>
                </tr>
                <tr>
                  <td>db.get(2)</td>
                  <td>Map에서 key에 해당하는 값을 반환</td>
                  <td>blog</td>
                </tr>
                <tr>
                  <td>db.delete(name)</td>
                  <td>Map에서 key에 해당하는 요소 제거</td>
                  <td>
                    Map(4) {1 => 'news', 2 => 'blog', 3 => 'bag', 'age' => 20 }
                  </td>
                </tr>
                <tr>
                  <td>db.clear()</td>
                  <td>Map의 모든 key-value 값을 제거</td>
                  <td>Map(0) {}</td>
                </tr>
                <tr>
                  <td>db.has('name')</td>
                  <td>
                    Map에서 key에 해당하는 값이 존재하는지 boolean값으로 반환
                  </td>
                  <td>false</td>
                </tr>
              </table>
            </div>
            <div class="content notion-3">
              <pre class="info">
const db = new Map();
db.set(1, 'news').set(2, 'blog').set('name', 'dung').set(3, 'bag')
위의 Map 객체를 이용하여 다양한 속성과 메서드를 알아봅시다.</pre
              >
              <table class="mt-10 child-pd-10">
                <tr class="bb1">
                  <th>속성과 메서드</th>
                  <th>설명</th>
                  <th>결과</th>
                </tr>
                <tr>
                  <td>db.keys()</td>
                  <td>
                    Map에 삽입된 순서에 따라 요소의 key를 포함하는 반복자를 반환
                  </td>
                  <td>[Map Iterator] { 1, 2, 3, 'age' }</td>
                </tr>
                <tr>
                  <td>db.values()</td>
                  <td>
                    Map에 삽입된 순서에 따라 요소의 value 값을 포함 하는
                    반복자를 반환
                  </td>
                  <td>[Map Iterator] { 'news', 'blog', 'bag', 20 }</td>
                </tr>
                <tr>
                  <td>
                    const dbIterator = db[symbole.iterator]()<br />
                    const dbIterator = db.entries();
                  </td>
                  <td>
                    Map 객체의 반복기능 프로토콜을 구현하여 for...of와 같은
                    반복이 필요한 대부분의 구문에서 사용할수 있게 함
                  </td>
                  <td>
                    [Map Entries] { [ 1, 'news' ], [ 2, 'blog' ], [ 3, 'bag' ],
                    [ 'age', 20 ] }
                  </td>
                </tr>
                <tr>
                  <td>
                    db.forEach((value, key) => {<br />
                    console.log(key + value);<br />
                    });
                  </td>
                  <td>
                    Map 객체 삽입 순서에 따라 각각의 key-value 쌍마다 콜백함수를
                    실행
                  </td>
                  <td>
                    1news<br />
                    2blog<br />
                    3bag<br />
                    age20
                  </td>
                </tr>
              </table>
            </div>
            <button
              type="button"
              class="btn-one"
              onclick="onButtonOne('week4','part3')"
            >
              1
            </button>
            <button
              type="button"
              class="btn-two"
              onclick="onButtonTwo('week4','part3')"
            >
              2
            </button>
            <button
              type="button"
              class="btn-third"
              onclick="onButtonThird('week4','part3')"
            >
              3
            </button>
          </article>
        </div>
      </div>
    </div>
  </body>
</html>
